ys <- sapply(X = 1:N, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = 0, to = 1, by = 0.25)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1:N, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = 0, to = 1, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1:N, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
seq(0, 1, 0.25)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1:N, FUN = function(i) {
y0[i + 1] <- y0[i] + h * func(xs[i], y0[i])
})
y0
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1:N, FUN = function(i) {
y0[i + 1] <- y0[i] + h * func(xs[i], y0[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1:N, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
ys
}
MetodoEuler()
MetodoEuler
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
0.25^4
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 2:N, FUN = function(i) {
y[i] <- y[i - 1] + h * func(xs[i - 1], y[i - 1])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1:N, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
ys
}
MetodoEuler()
MetodoEuler
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1:N, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
y
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
y
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
numeric(10)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1, FUN = function(i) {
# y[i + 1] <- y[i] + h * func(xs[i], y[i])
y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
?`[`
z[2] = 10
z
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1, FUN = function(i) {
y[i + 1, drop = TRUE] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1, FUN = function(i) {
y[i + 1, drop = FALSE] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
z <- numeric(5)
z[1] <- 10
sapply(1:4, function(i) {
z[i + 1] <- z[i] + 3 * batata(i, i)
z
})
z
?sapply
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- vapply(X = 1, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- vapply(X = 1, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
}, FUN.VALUE = double)
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- vapply(X = 1, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
}, FUN.VALUE = c(double))
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
}, simplify = TRUE)
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
sapply(1:4, function(i) {
z[i + 1] <- z[i] + 3 * batata(i, i)
z
}, simplify = TRUE)
z <- numeric(5)
z[1] <- 10
sapply(1:4, function(i) {
z[i + 1] <- z[i] + 3 * batata(i, i)
z
}, simplify = TRUE)
?`[`
z <- numeric(5)
z[1] <- 10
sapply(1:4, function(i) {
z[i + 1, exact = TRUE] <- z[i] + 3 * batata(i, i)
z
})
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1, FUN = function(i) {
y[[i + 1]] <- y[i] + h * func(xs[i], y[i])
}, simplify = TRUE)
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1, FUN = function(i) {
y[[i + 1]] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
z[[3]] = 1
z
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[[1]] <- y0
ys <- sapply(X = 1, FUN = function(i) {
y[[i + 1]] <- y[[i]] + h * func(xs[[i]], y[[i]])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
library(dplyr)
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[[1]] <- y0
ys <- sapply(X = 1, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
ys <- sapply(X = 1:3, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
Metodo_Euler <- function(func, x0, xf, y0, N) {
h <- (xf - x0) / N
xs <- seq(from = x0, to = xf, by = h)
y <- numeric(N + 1)
y[1] <- y0
ys <- sapply(X = 1:3, FUN = function(i) {
y[i + 1] <- y[i] + h * func(xs[i], y[i])
})
ys
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
MetodoEuler(\(x, y) x^3 - y, 0, 2, 1, 0.25)
MetodoEuler()
MetodoEuler
Metodo_Euler <- function(func, x0, y0, xf, h) {
x <- seq(from = x0, to = xf, by = h)
y <- numeric(length(x))
y[1] <- y0
for(i in 2:length(x)) {
y[i] <- y[i - 1] + h * func(x[i - 1], y[i - 1])
}
tibble(x = x, y = y)
}
Metodo_Euler(\(x, y) x^3 - y, 0, 1, 2, 4)
Metodo_Euler(\(x, y) x^3 - y, 0, 2, 1, 0.25)
library(tidymodels)
library(randomForest)
library(timetk)
library(readxl)
library(visdat)
tidymodels_prefer()
dados <- read_excel("./WDOLFUT-DIARIO-02_01_2018_a_03-05-2023.xlsx",
col_types = c("date", "numeric", "numeric","numeric", "numeric")
)
setwd("/home/gabriel/Documents/model_mercado_financeiro")
library(tidymodels)
library(randomForest)
library(timetk)
library(readxl)
library(visdat)
tidymodels_prefer()
dados <- read_excel("./WDOLFUT-DIARIO-02_01_2018_a_03-05-2023.xlsx",
col_types = c("date", "numeric", "numeric","numeric", "numeric")
)
dados <- dados |> mutate(Ponto_Medio = log(round((Maxima + Minima)/ 2, 2)))
# modelo ponto médio
# receita ponto médio
dados_rec_medio <- dados  |>
recipe(Ponto_Medio ~., data = dados) |>
step_arrange(Data) |>
step_lag(Ponto_Medio, lag = c(1, 9, 22), role = "lag") |>
step_rm(c(Maxima, Minima)) |>
step_arrange(desc(Data)) |>
step_naomit()
dados_final_medio <- dados_rec_medio |> prep() |> bake(new_data = dados) |> drop_na() |>
mutate(y = log(Ponto_Medio) - log(lag_1_Ponto_Medio),
x1 = (lag_1_Ponto_Medio/lag_22_Ponto_Medio)^(1/21),
x2 = Abertura/lag_1_Ponto_Medio,
Data = Data,
.keep = "none")
rec_ponto_medio <- dados_final_medio |>
recipe(y ~., data = dados_final_medio)
# random forest com a engine ranger
rand_model <- rand_forest(min_n = tune(), trees = tune(), mtry = tune()) |>
set_engine("ranger", alpha = tune()) |>
set_mode("regression")
rand_params <- rand_model |>
extract_parameter_set_dials() |>
update(trees = trees(c(50, 1000)),
mtry = mtry(c(1, 3)),
alpha = mixture(),
min_n = min_n(c(2, 100))
)
# criando workflow
ponto_medio_wf <- workflow() |>
add_recipe(rec_ponto_medio) |>
add_model(rand_model)
# banco de teste e treinamento
amostra <- sample(2, nrow(dados_final_medio), replace = TRUE, prob = c(0.7, 0.3))
conjunto_treinamento_medio <- dados_final_medio[amostra == 1, ]
conjunto_teste_medio <- dados_final_medio[amostra == 2, ]
cv_ponto_medio <- vfold_cv(data = conjunto_treinamento_medio, v = 20)
tunagem_ponto_medio <-
tune_grid(
ponto_medio_wf,
resamples = cv_ponto_medio,
grid = 50L,
metrics = metric_set(rsq, rmse),
control = control_grid(save_pred = TRUE, verbose = TRUE, allow_par = FALSE),
param_info = rand_params
)
# modelo maximo
dados_rec_maxima <- dados  |>
recipe(Maxima ~., data = dados) |>
step_arrange(Data) |>
step_lag(Maxima, lag = c(1, 9, 22), role = "lag") |>
step_arrange(desc(Data)) |>
step_naomit()
dados_final_maxima <- dados_rec_maxima |> prep() |> bake(new_data = dados) |> drop_na() |>
mutate(y = log(Maxima) - log(lag_1_Maxima),
x1 = (lag_1_Maxima/lag_22_Maxima)^(1/21),
x2 = Abertura/lag_1_Maxima,
Data = Data,
.keep = "none")
rec_maxima <- dados_final_minima |>
recipe(y ~., data = dados_final_maxima)
library(tidymodels)
library(randomForest)
library(timetk)
library(readxl)
library(visdat)
tidymodels_prefer()
dados <- read_excel("./WDOLFUT-DIARIO-02_01_2018_a_03-05-2023.xlsx",
col_types = c("date", "numeric", "numeric","numeric", "numeric")
)
dados <- dados |> mutate(Ponto_Medio = log(round((Maxima + Minima)/ 2, 2)))
# modelo ponto médio
# receita ponto médio
dados_rec_medio <- dados  |>
recipe(Ponto_Medio ~., data = dados) |>
step_arrange(Data) |>
step_lag(Ponto_Medio, lag = c(1, 9, 22), role = "lag") |>
step_rm(c(Maxima, Minima)) |>
step_arrange(desc(Data)) |>
step_naomit()
dados_final_medio <- dados_rec_medio |> prep() |> bake(new_data = dados) |> drop_na() |>
mutate(y = log(Ponto_Medio) - log(lag_1_Ponto_Medio),
x1 = (lag_1_Ponto_Medio/lag_22_Ponto_Medio)^(1/21),
x2 = Abertura/lag_1_Ponto_Medio,
Data = Data,
.keep = "none")
rec_ponto_medio <- dados_final_medio |>
recipe(y ~., data = dados_final_medio)
# random forest com a engine ranger
rand_model <- rand_forest(min_n = tune(), trees = tune(), mtry = tune()) |>
set_engine("ranger", alpha = tune()) |>
set_mode("regression")
rand_params <- rand_model |>
extract_parameter_set_dials() |>
update(trees = trees(c(50, 1000)),
mtry = mtry(c(1, 3)),
alpha = mixture(),
min_n = min_n(c(2, 100))
)
# criando workflow
ponto_medio_wf <- workflow() |>
add_recipe(rec_ponto_medio) |>
add_model(rand_model)
# banco de teste e treinamento
amostra <- sample(2, nrow(dados_final_medio), replace = TRUE, prob = c(0.7, 0.3))
conjunto_treinamento_medio <- dados_final_medio[amostra == 1, ]
conjunto_teste_medio <- dados_final_medio[amostra == 2, ]
cv_ponto_medio <- vfold_cv(data = conjunto_treinamento_medio, v = 20)
tunagem_ponto_medio <-
tune_grid(
ponto_medio_wf,
resamples = cv_ponto_medio,
grid = 50L,
metrics = metric_set(rsq, rmse),
control = control_grid(save_pred = TRUE, verbose = TRUE, allow_par = FALSE),
param_info = rand_params
)
# modelo maximo
dados_rec_maxima <- dados  |>
recipe(Maxima ~., data = dados) |>
step_arrange(Data) |>
step_lag(Maxima, lag = c(1, 9, 22), role = "lag") |>
step_arrange(desc(Data)) |>
step_naomit()
dados_final_maxima <- dados_rec_maxima |> prep() |> bake(new_data = dados) |> drop_na() |>
mutate(y = log(Maxima) - log(lag_1_Maxima),
x1 = (lag_1_Maxima/lag_22_Maxima)^(1/21),
x2 = Abertura/lag_1_Maxima,
Data = Data,
.keep = "none")
rec_maxima <- dados_final_mixima |>
recipe(y ~., data = dados_final_maxima)
rec_maxima <- dados_final_maxima |>
recipe(y ~., data = dados_final_maxima)
conjunto_treinamento_maxima <- dados_final_maxima[amostra == 1, ]
conjunto_teste_maxima <- dados_final_maxima[amostra == 2, ]
cv_maxima <- vfold_cv(data = conjunto_treinamento_maxima, v = 20)
maxima_wf <- workflow() |>
add_recipe(rec_maxima) |>
add_model(rand_model)
tunagem_maxima <-
tune_grid(
maxima_wf,
resamples = cv_maxima,
grid = 50L,
metrics = metric_set(rsq, rmse),
control = control_grid(save_pred = TRUE, verbose = TRUE, allow_par = FALSE),
param_info = rand_params
)
tunagem_maxima |> show_best(metric = "rmse", n = 10)
tunagem_maxima |> show_best(metric = "rsq", n = 10)
tunagem_maxima |> show_best(metric = "rmse", n = 10)
minima_wf <- minima_wf |> finalize_workflow(select_best(tunagem_minima, "rmse"))
minima_wf
minima_wf <- workflow() |>
add_recipe(rec_minima) |>
add_model(rand_model)
dados_rec_minima <- dados |>
recipe(Minima ~., data = dados) |>
step_arrange(Data) |>
step_lag(Minima, lag = c(1, 9, 22), role = "lag") |>
step_arrange(desc(Data)) |>
step_naomit()
dados_final_minima <- dados_rec_minima |> prep() |> bake(new_data = dados) |> drop_na() |>
mutate(y = log(Minima) - log(lag_1_Minima),
x1 = (lag_1_Minima/lag_22_Minima)^(1/21),
x2 = Abertura/lag_1_Minima,
Data = Data,
.keep = "none")
rec_minima <- dados_final_minima |>
recipe(y ~., data = dados_final_minima)
conjunto_treinamento_minima <- dados_final_minima[amostra == 1, ]
conjunto_teste_minima <- dados_final_minima[amostra == 2, ]
cv_minima <- vfold_cv(data = conjunto_treinamento_minima, v = 20)
minima_wf <- workflow() |>
add_recipe(rec_minima) |>
add_model(rand_model)
tunagem_minima <-
tune_grid(
minima_wf,
resamples = cv_minima,
grid = 50L,
metrics = metric_set(rsq, rmse),
control = control_grid(save_pred = TRUE, verbose = TRUE, allow_par = FALSE),
param_info = rand_params
)
minima_wf <- minima_wf |> finalize_workflow(select_best(tunagem_minima, "rmse"))
minima_wf
ajuste_final <- last_fit(minima_wf, dados_final_minima, metrics = metric_set(rsq, rmse))
